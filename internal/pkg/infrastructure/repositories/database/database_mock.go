// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package database

import (
	"github.com/diwise/api-smartwater/internal/pkg/infrastructure/repositories/models"
	"sync"
	"time"
)

// Ensure, that DatastoreMock does implement Datastore.
// If this is not the case, regenerate this file with moq.
var _ Datastore = &DatastoreMock{}

// DatastoreMock is a mock implementation of Datastore.
//
// 	func TestSomethingThatUsesDatastore(t *testing.T) {
//
// 		// make and configure a mocked Datastore
// 		mockedDatastore := &DatastoreMock{
// 			GetWaterConsumptionsFunc: func(deviceId string, from time.Time, to time.Time, limit uint64) ([]models.WaterConsumption, error) {
// 				panic("mock out the GetWaterConsumptions method")
// 			},
// 			StoreWaterConsumptionFunc: func(entityId string, device string, consumption float64, timestamp time.Time) (*models.WaterConsumption, error) {
// 				panic("mock out the StoreWaterConsumption method")
// 			},
// 		}
//
// 		// use mockedDatastore in code that requires Datastore
// 		// and then make assertions.
//
// 	}
type DatastoreMock struct {
	// GetWaterConsumptionsFunc mocks the GetWaterConsumptions method.
	GetWaterConsumptionsFunc func(deviceId string, from time.Time, to time.Time, limit uint64) ([]models.WaterConsumption, error)

	// StoreWaterConsumptionFunc mocks the StoreWaterConsumption method.
	StoreWaterConsumptionFunc func(entityId string, device string, consumption float64, timestamp time.Time) (*models.WaterConsumption, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetWaterConsumptions holds details about calls to the GetWaterConsumptions method.
		GetWaterConsumptions []struct {
			// DeviceId is the deviceId argument value.
			DeviceId string
			// From is the from argument value.
			From time.Time
			// To is the to argument value.
			To time.Time
			// Limit is the limit argument value.
			Limit uint64
		}
		// StoreWaterConsumption holds details about calls to the StoreWaterConsumption method.
		StoreWaterConsumption []struct {
			// EntityId is the entityId argument value.
			EntityId string
			// Device is the device argument value.
			Device string
			// Consumption is the consumption argument value.
			Consumption float64
			// Timestamp is the timestamp argument value.
			Timestamp time.Time
		}
	}
	lockGetWaterConsumptions  sync.RWMutex
	lockStoreWaterConsumption sync.RWMutex
}

// GetWaterConsumptions calls GetWaterConsumptionsFunc.
func (mock *DatastoreMock) GetWaterConsumptions(deviceId string, from time.Time, to time.Time, limit uint64) ([]models.WaterConsumption, error) {
	if mock.GetWaterConsumptionsFunc == nil {
		panic("DatastoreMock.GetWaterConsumptionsFunc: method is nil but Datastore.GetWaterConsumptions was just called")
	}
	callInfo := struct {
		DeviceId string
		From     time.Time
		To       time.Time
		Limit    uint64
	}{
		DeviceId: deviceId,
		From:     from,
		To:       to,
		Limit:    limit,
	}
	mock.lockGetWaterConsumptions.Lock()
	mock.calls.GetWaterConsumptions = append(mock.calls.GetWaterConsumptions, callInfo)
	mock.lockGetWaterConsumptions.Unlock()
	return mock.GetWaterConsumptionsFunc(deviceId, from, to, limit)
}

// GetWaterConsumptionsCalls gets all the calls that were made to GetWaterConsumptions.
// Check the length with:
//     len(mockedDatastore.GetWaterConsumptionsCalls())
func (mock *DatastoreMock) GetWaterConsumptionsCalls() []struct {
	DeviceId string
	From     time.Time
	To       time.Time
	Limit    uint64
} {
	var calls []struct {
		DeviceId string
		From     time.Time
		To       time.Time
		Limit    uint64
	}
	mock.lockGetWaterConsumptions.RLock()
	calls = mock.calls.GetWaterConsumptions
	mock.lockGetWaterConsumptions.RUnlock()
	return calls
}

// StoreWaterConsumption calls StoreWaterConsumptionFunc.
func (mock *DatastoreMock) StoreWaterConsumption(entityId string, device string, consumption float64, timestamp time.Time) (*models.WaterConsumption, error) {
	if mock.StoreWaterConsumptionFunc == nil {
		panic("DatastoreMock.StoreWaterConsumptionFunc: method is nil but Datastore.StoreWaterConsumption was just called")
	}
	callInfo := struct {
		EntityId    string
		Device      string
		Consumption float64
		Timestamp   time.Time
	}{
		EntityId:    entityId,
		Device:      device,
		Consumption: consumption,
		Timestamp:   timestamp,
	}
	mock.lockStoreWaterConsumption.Lock()
	mock.calls.StoreWaterConsumption = append(mock.calls.StoreWaterConsumption, callInfo)
	mock.lockStoreWaterConsumption.Unlock()
	return mock.StoreWaterConsumptionFunc(entityId, device, consumption, timestamp)
}

// StoreWaterConsumptionCalls gets all the calls that were made to StoreWaterConsumption.
// Check the length with:
//     len(mockedDatastore.StoreWaterConsumptionCalls())
func (mock *DatastoreMock) StoreWaterConsumptionCalls() []struct {
	EntityId    string
	Device      string
	Consumption float64
	Timestamp   time.Time
} {
	var calls []struct {
		EntityId    string
		Device      string
		Consumption float64
		Timestamp   time.Time
	}
	mock.lockStoreWaterConsumption.RLock()
	calls = mock.calls.StoreWaterConsumption
	mock.lockStoreWaterConsumption.RUnlock()
	return calls
}
