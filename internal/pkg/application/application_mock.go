// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package application

import (
	"github.com/diwise/api-smartwater/internal/pkg/infrastructure/repositories/models"
	"sync"
	"time"
)

// Ensure, that ApplicationMock does implement Application.
// If this is not the case, regenerate this file with moq.
var _ Application = &ApplicationMock{}

// ApplicationMock is a mock implementation of Application.
//
// 	func TestSomethingThatUsesApplication(t *testing.T) {
//
// 		// make and configure a mocked Application
// 		mockedApplication := &ApplicationMock{
// 			RetrieveWaterConsumptionsFunc: func(deviceId string, from time.Time, to time.Time, limit uint64) ([]models.WaterConsumption, error) {
// 				panic("mock out the RetrieveWaterConsumptions method")
// 			},
// 			UpdateWaterConsumptionFunc: func(device string, consumption float64, timestamp time.Time) error {
// 				panic("mock out the UpdateWaterConsumption method")
// 			},
// 		}
//
// 		// use mockedApplication in code that requires Application
// 		// and then make assertions.
//
// 	}
type ApplicationMock struct {
	// RetrieveWaterConsumptionsFunc mocks the RetrieveWaterConsumptions method.
	RetrieveWaterConsumptionsFunc func(deviceId string, from time.Time, to time.Time, limit uint64) ([]models.WaterConsumption, error)

	// UpdateWaterConsumptionFunc mocks the UpdateWaterConsumption method.
	UpdateWaterConsumptionFunc func(device string, consumption float64, timestamp time.Time) error

	// calls tracks calls to the methods.
	calls struct {
		// RetrieveWaterConsumptions holds details about calls to the RetrieveWaterConsumptions method.
		RetrieveWaterConsumptions []struct {
			// DeviceId is the deviceId argument value.
			DeviceId string
			// From is the from argument value.
			From time.Time
			// To is the to argument value.
			To time.Time
			// Limit is the limit argument value.
			Limit uint64
		}
		// UpdateWaterConsumption holds details about calls to the UpdateWaterConsumption method.
		UpdateWaterConsumption []struct {
			// Device is the device argument value.
			Device string
			// Consumption is the consumption argument value.
			Consumption float64
			// Timestamp is the timestamp argument value.
			Timestamp time.Time
		}
	}
	lockRetrieveWaterConsumptions sync.RWMutex
	lockUpdateWaterConsumption    sync.RWMutex
}

// RetrieveWaterConsumptions calls RetrieveWaterConsumptionsFunc.
func (mock *ApplicationMock) RetrieveWaterConsumptions(deviceId string, from time.Time, to time.Time, limit uint64) ([]models.WaterConsumption, error) {
	if mock.RetrieveWaterConsumptionsFunc == nil {
		panic("ApplicationMock.RetrieveWaterConsumptionsFunc: method is nil but Application.RetrieveWaterConsumptions was just called")
	}
	callInfo := struct {
		DeviceId string
		From     time.Time
		To       time.Time
		Limit    uint64
	}{
		DeviceId: deviceId,
		From:     from,
		To:       to,
		Limit:    limit,
	}
	mock.lockRetrieveWaterConsumptions.Lock()
	mock.calls.RetrieveWaterConsumptions = append(mock.calls.RetrieveWaterConsumptions, callInfo)
	mock.lockRetrieveWaterConsumptions.Unlock()
	return mock.RetrieveWaterConsumptionsFunc(deviceId, from, to, limit)
}

// RetrieveWaterConsumptionsCalls gets all the calls that were made to RetrieveWaterConsumptions.
// Check the length with:
//     len(mockedApplication.RetrieveWaterConsumptionsCalls())
func (mock *ApplicationMock) RetrieveWaterConsumptionsCalls() []struct {
	DeviceId string
	From     time.Time
	To       time.Time
	Limit    uint64
} {
	var calls []struct {
		DeviceId string
		From     time.Time
		To       time.Time
		Limit    uint64
	}
	mock.lockRetrieveWaterConsumptions.RLock()
	calls = mock.calls.RetrieveWaterConsumptions
	mock.lockRetrieveWaterConsumptions.RUnlock()
	return calls
}

// UpdateWaterConsumption calls UpdateWaterConsumptionFunc.
func (mock *ApplicationMock) UpdateWaterConsumption(device string, consumption float64, timestamp time.Time) error {
	if mock.UpdateWaterConsumptionFunc == nil {
		panic("ApplicationMock.UpdateWaterConsumptionFunc: method is nil but Application.UpdateWaterConsumption was just called")
	}
	callInfo := struct {
		Device      string
		Consumption float64
		Timestamp   time.Time
	}{
		Device:      device,
		Consumption: consumption,
		Timestamp:   timestamp,
	}
	mock.lockUpdateWaterConsumption.Lock()
	mock.calls.UpdateWaterConsumption = append(mock.calls.UpdateWaterConsumption, callInfo)
	mock.lockUpdateWaterConsumption.Unlock()
	return mock.UpdateWaterConsumptionFunc(device, consumption, timestamp)
}

// UpdateWaterConsumptionCalls gets all the calls that were made to UpdateWaterConsumption.
// Check the length with:
//     len(mockedApplication.UpdateWaterConsumptionCalls())
func (mock *ApplicationMock) UpdateWaterConsumptionCalls() []struct {
	Device      string
	Consumption float64
	Timestamp   time.Time
} {
	var calls []struct {
		Device      string
		Consumption float64
		Timestamp   time.Time
	}
	mock.lockUpdateWaterConsumption.RLock()
	calls = mock.calls.UpdateWaterConsumption
	mock.lockUpdateWaterConsumption.RUnlock()
	return calls
}
